<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Monitor Puerta Pro</title>
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <script type="module" src="capacitor.js"></script>
    
    <style>
        :root { --primary: #2ecc71; --danger: #e74c3c; --bg: #111; }
        body { background: var(--bg); color: #fff; font-family: -apple-system, sans-serif; margin: 0; display: flex; flex-direction: column; height: 100vh; overflow: hidden; }
        
        #console-log { position: absolute; top: 10px; left: 10px; font-size: 8px; opacity: 0.7; z-index: 5; background: rgba(0,0,0,0.7); padding: 8px; border-radius: 3px; max-width: 85%; max-height: 150px; overflow: auto; font-family: monospace; }
        #network-badge { position: absolute; top: 15px; right: 15px; z-index: 10; padding: 5px 12px; border-radius: 15px; background: rgba(0,0,0,0.6); font-size: 11px; display: flex; align-items: center; gap: 6px; }
        .dot { width: 8px; height: 8px; border-radius: 50%; background: #666; }
        .dot.online { background: #2ecc71; box-shadow: 0 0 5px #2ecc71; animation: pulse-dot 2s infinite; }
        .dot.offline { background: #e74c3c; }
        
        @keyframes pulse-dot { 0%, 100% { opacity: 1; } 50% { opacity: 0.5; } }

        #main-wrapper { flex-grow: 1; position: relative; display: flex; flex-direction: column; align-items: center; justify-content: center; }
        
        canvas#wave-visualizer { width: 100%; height: 300px; position: absolute; top: 50%; left: 0; transform: translateY(-50%); opacity: 0; transition: opacity 0.5s; z-index: 1; }
        canvas.active { opacity: 1 !important; }

        .status-container { z-index: 5; text-align: center; }
        .status-text { font-size: 20px; font-weight: 300; letter-spacing: 1px; color: #ccc; margin-bottom: 20px; }
        .avatar-waiting { width: 80px; height: 80px; border-radius: 50%; background: linear-gradient(135deg, #333, #111); border: 1px solid #444; display: flex; align-items: center; justify-content: center; font-size: 30px; margin: 0 auto; box-shadow: 0 10px 20px rgba(0,0,0,0.3); }

        .controls-layer { position: absolute; bottom: 50px; width: 100%; display: flex; justify-content: center; gap: 30px; z-index: 20; transition: transform 0.3s; }
        .controls-layer.hidden { transform: translateY(150px); }
        .btn { width: 70px; height: 70px; border-radius: 50%; border: none; font-size: 28px; cursor: pointer; color: white; display: flex; align-items: center; justify-content: center; box-shadow: 0 10px 20px rgba(0,0,0,0.4); transition: transform 0.2s; }
        .btn:active { transform: scale(0.92); }
        
        .btn-answer { background: var(--primary); animation: pulse-ring 1.5s infinite; }
        .btn-hangup { background: var(--danger); }
        .btn-mute { background: #f39c12; width: 50px; height: 50px; font-size: 20px; position: absolute; bottom: 20px; right: 30px; }
        .btn-mute.muted { background: #e74c3c; }

        @keyframes pulse-ring { 0% { box-shadow: 0 0 0 0 rgba(46, 204, 113, 0.7); } 70% { box-shadow: 0 0 0 20px rgba(46, 204, 113, 0); } 100% { box-shadow: 0 0 0 0 rgba(46, 204, 113, 0); } }

        #onboarding { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: #000; z-index: 100; display: flex; flex-direction: column; align-items: center; justify-content: center; text-align: center; padding: 20px; }
        .btn-start { padding: 15px 40px; background: white; color: black; border: none; border-radius: 30px; font-weight: bold; font-size: 18px; margin-top: 30px; cursor: pointer; }
        
        #keepalive-status { position: absolute; bottom: 10px; left: 10px; font-size: 10px; background: rgba(0,0,0,0.5); padding: 5px 10px; border-radius: 10px; }
    </style>
</head>
<body>

    <div id="onboarding">
        <div style="font-size: 50px; margin-bottom: 20px;">üö™</div>
        <h1 style="margin:0; font-size:24px;">Monitor Puerta V4</h1>
        <p style="color:#888; font-size:14px;">Sistema anti-delay con keepalive</p>
        <button class="btn-start" onclick="iniciarApp()">Entrar</button>
    </div>

    <div id="console-log">Iniciando sistema...</div>
    <div id="network-badge"><div id="net-dot" class="dot offline"></div><span id="net-text">Desconectado</span></div>
    <div id="keepalive-status">‚è±Ô∏è Keepalive: <span id="keepalive-count">0</span></div>

    <div id="main-wrapper">
        <canvas id="wave-visualizer"></canvas>
        <div class="status-container">
            <div id="avatar" class="avatar-waiting">üîí</div>
            <div id="status-text" class="status-text">Esperando conexi√≥n...</div>
        </div>

        <div id="controls-incoming" class="controls-layer hidden">
            <button class="btn btn-hangup" onclick="rechazarLlamada()">‚ùå</button>
            <button class="btn btn-answer" onclick="contestarLlamada()">üìû</button>
        </div>

        <div id="controls-active" class="controls-layer hidden">
            <button class="btn btn-hangup" onclick="finalizarLlamada()">üî¥</button>
        </div>
        
        <button id="btn-mute" class="btn btn-mute hidden" onclick="toggleMute()" style="display:none;">üé§</button>
    </div>

    <audio id="remoteAudio" autoplay></audio>

    <script>
        const MY_ID = "puerta-admin-v2"; 
        const API_URL = 'https://registrarreceptor-6rmawrifca-uc.a.run.app';
        
        let peer = null;
        let currentCall = null;
        let currentDataConn = null;
        let localStream = null;
        let incomingCallRequest = null;
        let audioContext = null;
        let analyser = null;
        let ringtoneOscillator = null; 
        let callTimeout = null;
        let isMuted = false;
        let wakeLock = null;
        let keepaliveInterval = null;
        let keepaliveCount = 0;
        let isCapacitorAvailable = false;
        let PushNotifications = null;

        // ============================================
        // SISTEMA DE LOGS CON TIMESTAMPS
        // ============================================
        function log(msg) {
            const logDiv = document.getElementById('console-log');
            const time = new Date().toLocaleTimeString();
            logDiv.innerHTML = `<div>[${time}] ${msg}</div>` + logDiv.innerHTML;
            console.log(`[${time}] ${msg}`);
        }

        // ============================================
        // WAKE LOCK - Mantener pantalla activa
        // ============================================
        async function requestWakeLock() {
            try {
                if ('wakeLock' in navigator) {
                    wakeLock = await navigator.wakeLock.request('screen');
                    log('‚úÖ Wake Lock ACTIVADO');
                    
                    wakeLock.addEventListener('release', () => {
                        log('‚ö†Ô∏è Wake Lock liberado - re-adquiriendo...');
                        setTimeout(requestWakeLock, 100);
                    });
                } else {
                    log('‚ö†Ô∏è Wake Lock NO soportado en este navegador');
                }
            } catch (err) {
                log('‚ùå Wake Lock error: ' + err.message);
            }
        }

        document.addEventListener('visibilitychange', async () => {
            if (document.visibilityState === 'visible' && wakeLock === null) {
                await requestWakeLock();
            }
        });

        // ============================================
        // KEEPALIVE AGRESIVO - Evitar que PeerJS se duerma
        // ============================================
        function iniciarKeepalive() {
            if (keepaliveInterval) clearInterval(keepaliveInterval);
            
            keepaliveInterval = setInterval(() => {
                keepaliveCount++;
                document.getElementById('keepalive-count').innerText = keepaliveCount;
                
                // 1. Verificar estado de Peer
                if (peer && peer.disconnected) {
                    log('üîÑ PEER DESCONECTADO - Reconectando...');
                    peer.reconnect();
                }
                
                // 2. Ping al servidor de se√±alizaci√≥n
                if (peer && peer.socket && peer.socket.readyState === WebSocket.OPEN) {
                    try {
                        peer.socket.send(JSON.stringify({ type: 'PING' }));
                        log('üíì Keepalive enviado - Conexi√≥n VIVA');
                    } catch (e) {
                        log('‚ö†Ô∏è Error en keepalive: ' + e.message);
                    }
                } else {
                    log('‚ö†Ô∏è Socket no disponible - Estado: ' + (peer?.socket?.readyState || 'null'));
                }
                
                // 3. Verificar AudioContext no suspendido
                if (audioContext && audioContext.state === 'suspended') {
                    audioContext.resume();
                    log('üîä AudioContext resumido');
                }
                
            }, 15000); // Cada 15 segundos (m√°s agresivo que antes)
        }

        // ============================================
        // INICIALIZACI√ìN PRINCIPAL
        // ============================================
        window.iniciarApp = async function() {
            try {
                log('üöÄ INICIANDO SISTEMA ANTI-DELAY...');
                
                // 1. AudioContext
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                log('‚úÖ AudioContext creado');
                
                // 2. Permisos de micr√≥fono (liberar inmediatamente)
                const streamTemp = await navigator.mediaDevices.getUserMedia({ audio: true, video: false });
                streamTemp.getTracks().forEach(track => track.stop());
                log('‚úÖ Permisos de audio concedidos');
                
                // 3. Ocultar onboarding
                document.getElementById('onboarding').style.opacity = '0';
                setTimeout(() => document.getElementById('onboarding').remove(), 500);
                
                // 4. Wake Lock
                await requestWakeLock();
                
                // 5. Iniciar Capacitor si est√° disponible
                await iniciarCapacitor();
                
                // 6. Iniciar PeerJS
                iniciarPeer();
                
                // 7. Visualizador
                iniciarVisualizador();
                
                // 8. KEEPALIVE AGRESIVO (CR√çTICO)
                iniciarKeepalive();
                
                log('‚úÖ SISTEMA COMPLETAMENTE INICIADO');
                
            } catch (e) { 
                log('‚ùå ERROR CR√çTICO: ' + e.message);
                alert("Error: " + e.message); 
            }
        };

        // ============================================
        // CAPACITOR / FCM (Solo en Android)
        // ============================================
        async function iniciarCapacitor() {
            try {
                // Detectar si Capacitor est√° disponible
                if (window.Capacitor) {
                    log('üì± Capacitor DETECTADO - Modo Android');
                    isCapacitorAvailable = true;
                    
                    // Importar din√°micamente
                    const module = await import('@capacitor/push-notifications');
                    PushNotifications = module.PushNotifications;
                    
                    // Solicitar permisos
                    let perm = await PushNotifications.checkPermissions();
                    if (perm.receive === 'prompt') {
                        perm = await PushNotifications.requestPermissions();
                    }
                    
                    if (perm.receive !== 'granted') {
                        log('‚ö†Ô∏è Permisos FCM DENEGADOS');
                        return;
                    }

                    // Crear canal de alta prioridad
                    await PushNotifications.createChannel({
                        id: 'timbre_urgente',      
                        name: 'Timbre de Puerta',
                        importance: 5,
                        visibility: 1,
                        vibration: true,
                        sound: 'default'
                    });
                    log('‚úÖ Canal FCM creado');

                    // Registrar
                    await PushNotifications.register();
                    log('‚úÖ FCM Registro iniciado');
                    
                    // Listeners
                    PushNotifications.addListener('registration', async (token) => {
                        log('üì≤ Token FCM recibido');
                        await registrarEnServidor(token.value);
                    });

                    PushNotifications.addListener('pushNotificationReceived', (notification) => {
                        log('üîî PUSH RECIBIDA EN FOREGROUND');
                        console.log(notification);
                    });

                } else {
                    log('üåê Modo WEB - FCM no disponible');
                }
            } catch (e) { 
                log('‚ö†Ô∏è Capacitor no disponible: ' + e.message);
            }
        }

        async function registrarEnServidor(token) {
            try {
                log('üì° Registrando token FCM en servidor...');
                const res = await fetch(API_URL, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ token: token, sala: 'puerta-principal' })
                });
                const data = await res.json();
                log('‚úÖ Token registrado: ' + data.message);
            } catch (e) {
                log('‚ùå Error registro token: ' + e.message);
            }
        }

        // ============================================
        // PEERJS CON RECONEXI√ìN INTELIGENTE
        // ============================================
        function iniciarPeer() {
            log('üîå Iniciando PeerJS...');
            if (peer) {
                peer.destroy();
                log('‚ôªÔ∏è Peer anterior destruido');
            }
            
            peer = new Peer(MY_ID, {
                debug: 2,
                config: { 
                    iceServers: [
                        { urls: 'stun:stun.l.google.com:19302' },
                        { urls: 'stun:stun1.l.google.com:19302' },
                        { urls: 'stun:stun2.l.google.com:19302' }
                    ] 
                },
                // Configuraci√≥n anti-timeout
                pingInterval: 5000 // Ping cada 5 segundos
            });

            peer.on('open', (id) => {
                log('‚úÖ PeerJS CONECTADO: ' + id);
                updateNetworkStatus('online');
                setStatus("‚úÖ Listo para recibir llamadas");
            });

            // Canal de datos (para colgar)
            peer.on('connection', (conn) => {
                log('üì® Canal de datos establecido');
                currentDataConn = conn;
                
                conn.on('open', () => log('‚úÖ Canal de datos ABIERTO'));
                
                conn.on('data', (data) => {
                    log('üì© Dato recibido: ' + data);
                    if (data === 'CORTAR') finalizarLlamada(false);
                });
                
                conn.on('close', () => {
                    log('üì™ Canal de datos cerrado');
                });
            });

            // LLAMADA ENTRANTE
            peer.on('call', (call) => {
                log('üîîüîîüîî LLAMADA ENTRANTE de ' + call.peer);
                incomingCallRequest = call;
                
                setStatus("üîî TIMBRE SONANDO");
                document.getElementById('avatar').innerText = "üîî";
                document.getElementById('controls-incoming').classList.remove('hidden');
                
                startRinging();
                if (navigator.vibrate) {
                    navigator.vibrate([500, 200, 500, 200, 500, 200, 1000]);
                }
                
                // Auto-rechazar despu√©s de 30 segundos
                if (callTimeout) clearTimeout(callTimeout);
                callTimeout = setTimeout(() => {
                    log('‚è±Ô∏è Timeout: Llamada no contestada');
                    rechazarLlamada();
                }, 30000);
            });

            peer.on('error', (err) => {
                log('‚ùå PeerJS Error: ' + err.type + ' - ' + err.message);
                updateNetworkStatus('offline');
                
                if (err.type === 'unavailable-id') {
                    alert("‚ö†Ô∏è Este ID ya est√° en uso. Cierra otras pesta√±as.");
                } else if (err.type === 'network' || err.type === 'server-error') {
                    log('üîÑ Error de red, reintentando en 3s...');
                    setTimeout(iniciarPeer, 3000);
                }
            });

            peer.on('disconnected', () => { 
                log('‚ö†Ô∏è PeerJS DESCONECTADO');
                updateNetworkStatus('offline'); 
                setStatus("üì° Reconectando...");
                
                // Intentar reconectar inmediatamente
                setTimeout(() => {
                    if (peer && !peer.destroyed) {
                        peer.reconnect();
                    } else {
                        iniciarPeer();
                    }
                }, 2000);
            });

            peer.on('close', () => {
                log('üî¥ Peer CERRADO completamente');
            });
        }

        // ============================================
        // CONTESTAR LLAMADA
        // ============================================
        window.contestarLlamada = async function() {
            if (!incomingCallRequest) {
                log('‚ö†Ô∏è No hay llamada entrante');
                return;
            }
            
            log('üìû CONTESTANDO LLAMADA...');
            stopRinging();
            if (callTimeout) clearTimeout(callTimeout);
            
            try {
                // Activar micr√≥fono REAL
                localStream = await navigator.mediaDevices.getUserMedia({ 
                    audio: {
                        echoCancellation: true,
                        noiseSuppression: true,
                        autoGainControl: true
                    }, 
                    video: false 
                });
                log('‚úÖ Micr√≥fono ACTIVADO');
                
                // Actualizar UI
                document.getElementById('controls-incoming').classList.add('hidden');
                document.getElementById('controls-active').classList.remove('hidden');
                document.getElementById('btn-mute').style.display = 'flex'; 
                setStatus("üü¢ EN LLAMADA");
                document.getElementById('avatar').innerText = "üîä";
                
                // Contestar con nuestro stream
                currentCall = incomingCallRequest;
                currentCall.answer(localStream);
                log('‚úÖ Respuesta enviada al visitante');
                
                // Recibir su audio
                currentCall.on('stream', (remoteStream) => {
                    log('üîä AUDIO REMOTO RECIBIDO');
                    document.getElementById('remoteAudio').srcObject = remoteStream;
                    conectarVisualizador(remoteStream);
                });
                
                currentCall.on('close', () => {
                    log('üìû Llamada CERRADA por el otro lado');
                    finalizarLlamada(false);
                });

                currentCall.on('error', (err) => {
                    log('‚ùå Error en llamada: ' + err);
                });

            } catch (err) { 
                log('‚ùå Error al activar micr√≥fono: ' + err.message);
                alert("Error de micr√≥fono: " + err.message); 
                rechazarLlamada(); 
            }
        };

        window.rechazarLlamada = function() {
            log('‚ùå LLAMADA RECHAZADA');
            if (incomingCallRequest) incomingCallRequest.close();
            resetState();
        };

        window.finalizarLlamada = function(enviarAviso = true) {
            log('üî¥ FINALIZANDO LLAMADA...');
            
            if (enviarAviso && currentDataConn && currentDataConn.open) {
                try {
                    currentDataConn.send('CORTAR');
                    log('üì§ Se√±al CORTAR enviada');
                } catch (e) {
                    log('‚ö†Ô∏è Error enviando CORTAR: ' + e.message);
                }
            }
            
            if (currentCall) currentCall.close();
            if (currentDataConn) currentDataConn.close();
            resetState();
        };

        function resetState() {
            stopRinging();
            if (callTimeout) clearTimeout(callTimeout);
            
            // Liberar micr√≥fono
            if (localStream) {
                localStream.getTracks().forEach(track => {
                    track.stop();
                    log('üé§ Track de audio detenido');
                });
                localStream = null;
            }

            currentCall = null; 
            incomingCallRequest = null; 
            currentDataConn = null;
            
            document.getElementById('controls-incoming').classList.add('hidden');
            document.getElementById('controls-active').classList.add('hidden');
            document.getElementById('btn-mute').style.display = 'none';
            document.getElementById('wave-visualizer').classList.remove('active');
            
            setStatus("‚úÖ Listo para recibir llamadas");
            document.getElementById('avatar').innerText = "üîí";
            updateNetworkStatus('online');
            log('‚úÖ Estado RESETEADO');
        }

        // ============================================
        // UTILIDADES
        // ============================================
        function startRinging() {
            if (!audioContext) return;
            try {
                ringtoneOscillator = audioContext.createOscillator();
                const gain = audioContext.createGain();
                ringtoneOscillator.type = 'square';
                ringtoneOscillator.frequency.setValueAtTime(800, audioContext.currentTime);
                ringtoneOscillator.connect(gain);
                gain.connect(audioContext.destination);
                gain.gain.value = 0.15;
                ringtoneOscillator.start();
                log('üîî Timbre sonando');
            } catch (e) {
                log('‚ö†Ô∏è Error en timbre: ' + e.message);
            }
        }

        function stopRinging() {
            if (ringtoneOscillator) { 
                try { 
                    ringtoneOscillator.stop(); 
                    log('üîï Timbre detenido');
                } catch(e){} 
                ringtoneOscillator = null; 
            }
            if (navigator.vibrate) navigator.vibrate(0);
        }

        window.toggleMute = function() {
            if (!localStream) return;
            const track = localStream.getAudioTracks()[0];
            isMuted = !isMuted;
            track.enabled = !isMuted;
            document.getElementById('btn-mute').classList.toggle('muted', isMuted);
            log(isMuted ? 'üîá Micr√≥fono MUTEADO' : 'üîä Micr√≥fono ACTIVO');
        };

        function iniciarVisualizador() {
            const canvas = document.getElementById('wave-visualizer');
            const ctx = canvas.getContext('2d');
            canvas.width = window.innerWidth; 
            canvas.height = 300;
            
            function drawWave() {
                requestAnimationFrame(drawWave);
                if (!analyser) return;
                
                const bufferLength = analyser.frequencyBinCount; 
                const dataArray = new Uint8Array(bufferLength);
                analyser.getByteTimeDomainData(dataArray);
                
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.lineWidth = 2; 
                ctx.strokeStyle = '#2ecc71'; 
                ctx.beginPath();
                
                const sliceWidth = canvas.width / bufferLength; 
                let x = 0;
                
                for (let i = 0; i < bufferLength; i++) {
                    const v = dataArray[i] / 128.0; 
                    const y = v * (canvas.height / 2);
                    if (i === 0) ctx.moveTo(x, y); 
                    else ctx.lineTo(x, y); 
                    x += sliceWidth;
                }
                
                ctx.lineTo(canvas.width, canvas.height / 2); 
                ctx.stroke();
            }
            
            drawWave();
        }

        function conectarVisualizador(stream) {
            if (!audioContext) return;
            try {
                const source = audioContext.createMediaStreamSource(stream);
                analyser = audioContext.createAnalyser();
                analyser.fftSize = 2048;
                source.connect(analyser);
                document.getElementById('wave-visualizer').classList.add('active');
                log('üìä Visualizador CONECTADO');
            } catch (e) {
                log('‚ö†Ô∏è Error visualizador: ' + e.message);
            }
        }

        function setStatus(msg) { 
            document.getElementById('status-text').innerText = msg; 
        }
        
        function updateNetworkStatus(status) {
            const dot = document.getElementById('net-dot');
            const txt = document.getElementById('net-text');
            dot.className = 'dot ' + status;
            txt.innerText = status === 'online' ? 'En L√≠nea' : 'Desconectado';
        }

        // Cleanup al cerrar
        window.addEventListener('beforeunload', () => {
            if (keepaliveInterval) clearInterval(keepaliveInterval);
            if (peer) peer.destroy();
        });
    </script>
</body>
</html>
