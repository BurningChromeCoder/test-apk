<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>Monitor Puerta Pro</title>
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    
    <style>
        :root { --primary: #2ecc71; --danger: #e74c3c; --bg: #111; --glass: rgba(255,255,255,0.1); }
        body { background: var(--bg); color: #fff; font-family: -apple-system, sans-serif; margin: 0; display: flex; flex-direction: column; height: 100vh; overflow: hidden; }
        
        #console-log { position: absolute; top: 10px; left: 10px; font-size: 9px; opacity: 0.5; pointer-events: none; z-index: 5; text-shadow: 0 1px 2px #000; max-height: 100px; overflow: auto; }
        #network-badge { position: absolute; top: 15px; right: 15px; z-index: 10; padding: 5px 12px; border-radius: 15px; background: rgba(0,0,0,0.6); font-size: 11px; display: flex; align-items: center; gap: 6px; backdrop-filter: blur(5px); border: 1px solid rgba(255,255,255,0.1); }
        .dot { width: 8px; height: 8px; border-radius: 50%; background: #666; }
        .dot.online { background: #2ecc71; box-shadow: 0 0 5px #2ecc71; }
        .dot.offline { background: #e74c3c; }

        #main-wrapper { flex-grow: 1; position: relative; display: flex; flex-direction: column; align-items: center; justify-content: center; }
        
        canvas#wave-visualizer { width: 100%; height: 300px; position: absolute; top: 50%; left: 0; transform: translateY(-50%); opacity: 0; transition: opacity 0.5s; z-index: 1; }
        canvas.active { opacity: 1 !important; }

        .status-container { z-index: 5; text-align: center; }
        .status-text { font-size: 20px; font-weight: 300; letter-spacing: 1px; color: #ccc; margin-bottom: 20px; }
        .avatar-waiting { width: 80px; height: 80px; border-radius: 50%; background: linear-gradient(135deg, #333, #111); border: 1px solid #444; display: flex; align-items: center; justify-content: center; font-size: 30px; margin: 0 auto; box-shadow: 0 10px 20px rgba(0,0,0,0.3); }

        .controls-layer { position: absolute; bottom: 50px; width: 100%; display: flex; justify-content: center; gap: 30px; z-index: 20; transition: transform 0.3s; }
        .controls-layer.hidden { transform: translateY(150px); }
        .btn { width: 70px; height: 70px; border-radius: 50%; border: none; font-size: 28px; cursor: pointer; color: white; display: flex; align-items: center; justify-content: center; box-shadow: 0 10px 20px rgba(0,0,0,0.4); transition: transform 0.2s; }
        .btn:active { transform: scale(0.92); }
        
        .btn-answer { background: var(--primary); animation: pulse-ring 1.5s infinite; }
        .btn-hangup { background: var(--danger); }
        .btn-mute { background: #f39c12; width: 50px; height: 50px; font-size: 20px; position: absolute; bottom: 20px; right: 30px; }
        .btn-mute.muted { background: #e74c3c; }
        .btn-mute::after { content: ''; position: absolute; width: 100%; height: 2px; background: #fff; transform: rotate(45deg); opacity: 0; }
        .btn-mute.muted::after { opacity: 1; }

        @keyframes pulse-ring { 0% { box-shadow: 0 0 0 0 rgba(46, 204, 113, 0.7); } 70% { box-shadow: 0 0 0 20px rgba(46, 204, 113, 0); } 100% { box-shadow: 0 0 0 0 rgba(46, 204, 113, 0); } }

        #onboarding { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: #000; z-index: 100; display: flex; flex-direction: column; align-items: center; justify-content: center; text-align: center; padding: 20px; box-sizing: border-box; }
        .btn-start { padding: 15px 40px; background: white; color: black; border: none; border-radius: 30px; font-weight: bold; font-size: 18px; margin-top: 30px; }
    </style>
</head>
<body>

    <div id="onboarding">
        <div style="font-size: 50px; margin-bottom: 20px;">üö™</div>
        <h1 style="margin:0; font-size:24px;">Monitor Puerta V3.1</h1>
        <p style="color:#888;">Mantendremos la app activa en segundo plano</p>
        <button class="btn-start" onclick="iniciarApp()">Entrar</button>
    </div>

    <div id="console-log"></div>
    <div id="network-badge"><div id="net-dot" class="dot offline"></div><span id="net-text">Desconectado</span></div>

    <div id="main-wrapper">
        <canvas id="wave-visualizer"></canvas>
        <div class="status-container">
            <div id="avatar" class="avatar-waiting">üîí</div>
            <div id="status-text" class="status-text">Esperando conexi√≥n...</div>
        </div>

        <div id="controls-incoming" class="controls-layer hidden">
            <button class="btn btn-hangup" onclick="rechazarLlamada()">‚ùå</button>
            <button class="btn btn-answer" onclick="contestarLlamada()">üìû</button>
        </div>

        <div id="controls-active" class="controls-layer hidden">
            <button class="btn btn-hangup" onclick="finalizarLlamada()">üî¥</button>
        </div>
        
        <button id="btn-mute" class="btn btn-mute hidden" onclick="toggleMute()" style="display:none;">üé§</button>
    </div>

    <audio id="remoteAudio" autoplay></audio>

    <script type="module">
        import { PushNotifications } from '@capacitor/push-notifications';
        
        const MY_ID = "puerta-admin-v2"; 
        const API_URL = 'https://registrarreceptor-6rmawrifca-uc.a.run.app';
        
        let peer = null;
        let currentCall = null;
        let currentDataConn = null;
        let localStream = null;
        let incomingCallRequest = null;
        let audioContext = null;
        let analyser = null;
        let ringtoneOscillator = null; 
        let callTimeout = null;
        let isMuted = false;
        let reconnectInterval = null;
        let wakeLock = null;

        // SISTEMA DE LOGS
        function log(msg) {
            const logDiv = document.getElementById('console-log');
            const time = new Date().toLocaleTimeString();
            logDiv.innerHTML = `[${time}] ${msg}<br>` + logDiv.innerHTML;
        }

        // WAKE LOCK para mantener pantalla activa
        async function requestWakeLock() {
            try {
                if ('wakeLock' in navigator) {
                    wakeLock = await navigator.wakeLock.request('screen');
                    log('‚úÖ Wake Lock activado');
                    
                    wakeLock.addEventListener('release', () => {
                        log('‚ö†Ô∏è Wake Lock liberado');
                    });
                }
            } catch (err) {
                log('‚ùå Wake Lock error: ' + err.message);
            }
        }

        // RE-ADQUIRIR WAKE LOCK si la pantalla se apaga
        document.addEventListener('visibilitychange', async () => {
            if (wakeLock !== null && document.visibilityState === 'visible') {
                await requestWakeLock();
            }
        });

        window.iniciarApp = async function() {
            try {
                log('üöÄ Iniciando app...');
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                
                // Liberar micr√≥fono inicial
                const streamTemp = await navigator.mediaDevices.getUserMedia({ audio: true, video: false });
                streamTemp.getTracks().forEach(track => track.stop());
                log('‚úÖ Permisos de audio OK');
                
                document.getElementById('onboarding').style.opacity = '0';
                setTimeout(() => document.getElementById('onboarding').remove(), 500);
                
                await requestWakeLock();
                await iniciarFCM(); 
                iniciarPeer();
                iniciarVisualizador();
                
                // Mantener conexi√≥n activa con heartbeat
                setInterval(() => {
                    if (peer && peer.open) {
                        log('üíì Heartbeat - Conexi√≥n activa');
                    } else if (peer && peer.disconnected) {
                        log('‚ö†Ô∏è Peer desconectado, reconectando...');
                        peer.reconnect();
                    }
                }, 30000); // Cada 30 segundos
                
            } catch (e) { 
                log('‚ùå Error: ' + e.message);
                alert("Error permisos: " + e.message); 
            }
        };

        async function iniciarFCM() {
            try {
                log('üì± Iniciando FCM...');
                let perm = await PushNotifications.checkPermissions();
                if (perm.receive === 'prompt') {
                    perm = await PushNotifications.requestPermissions();
                }
                if (perm.receive !== 'granted') {
                    log('‚ùå Permisos FCM denegados');
                    return;
                }

                await PushNotifications.createChannel({
                    id: 'timbre_urgente',      
                    name: 'Timbre de Puerta',
                    importance: 5,             
                    visibility: 1,             
                    vibration: true,
                    sound: 'beep.wav'          
                });

                await PushNotifications.register();
                log('‚úÖ FCM Registrado');
                
                PushNotifications.addListener('registration', t => {
                    log('üì≤ Token FCM recibido');
                    registrarEnServidor(t.value);
                });

                // CR√çTICO: Escuchar notificaciones mientras la app est√° abierta
                PushNotifications.addListener('pushNotificationReceived', (notification) => {
                    log('üîî NOTIFICACI√ìN RECIBIDA EN FOREGROUND');
                    console.log('Push notification received:', notification);
                    
                    // Forzar que suene aunque la app est√© abierta
                    if (navigator.vibrate) navigator.vibrate([500, 200, 500]);
                });

                // Escuchar cuando el usuario toca la notificaci√≥n
                PushNotifications.addListener('pushNotificationActionPerformed', (notification) => {
                    log('üëÜ Usuario toc√≥ notificaci√≥n');
                    console.log('Push action performed:', notification);
                });

            } catch (e) { 
                log('‚ùå FCM Error: ' + e.message);
            }
        }

        async function registrarEnServidor(token) {
            try {
                log('üì° Registrando token en servidor...');
                const res = await fetch(API_URL, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ token: token, sala: 'puerta-principal' })
                });
                const data = await res.json();
                log('‚úÖ Token registrado: ' + data.message);
            } catch (e) {
                log('‚ùå Error registro: ' + e.message);
            }
        }

        function iniciarPeer() {
            log('üîå Conectando a PeerJS...');
            if (peer) peer.destroy(); 
            peer = new Peer(MY_ID, {
                debug: 2,
                config: { 
                    iceServers: [
                        { urls: 'stun:stun.l.google.com:19302' },
                        { urls: 'stun:stun1.l.google.com:19302' }
                    ] 
                }
            });

            peer.on('open', (id) => {
                log('‚úÖ PeerJS conectado: ' + id);
                updateNetworkStatus('online');
                setStatus("‚úÖ Listo para timbre");
                if (reconnectInterval) {
                    clearInterval(reconnectInterval);
                    reconnectInterval = null;
                }
            });

            // 1. Canal de datos (para colgar)
            peer.on('connection', (conn) => {
                log('üì® Canal de datos abierto');
                currentDataConn = conn;
                conn.on('data', (data) => {
                    log('üì© Dato recibido: ' + data);
                    if (data === 'CORTAR') finalizarLlamada(false);
                });
                conn.on('close', () => {
                    log('üì™ Canal de datos cerrado');
                    finalizarLlamada(false);
                });
            });

            // 2. Llamada de audio
            peer.on('call', (call) => {
                log('üîî LLAMADA ENTRANTE de ' + call.peer);
                incomingCallRequest = call;
                setStatus("üîî TIMBRE SONANDO");
                document.getElementById('avatar').innerText = "üîî";
                document.getElementById('controls-incoming').classList.remove('hidden');
                
                startRinging();
                if (navigator.vibrate) navigator.vibrate([500, 200, 500, 200, 1000]);
                
                if (callTimeout) clearTimeout(callTimeout);
                callTimeout = setTimeout(() => {
                    log('‚è±Ô∏è Timeout de llamada');
                    rechazarLlamada();
                }, 30000);
            });

            peer.on('error', (err) => {
                log('‚ùå PeerJS error: ' + err.type);
                updateNetworkStatus('offline');
                if (err.type === 'unavailable-id') {
                    setStatus("‚ö†Ô∏è ID en uso");
                    alert("Cierra otras pesta√±as de la app.");
                } else {
                    attemptReconnect();
                }
            });

            peer.on('disconnected', () => { 
                log('‚ö†Ô∏è PeerJS desconectado');
                updateNetworkStatus('offline'); 
                attemptReconnect(); 
            });
        }

        function attemptReconnect() {
            if (reconnectInterval) return;
            setStatus("üì° Reconectando...");
            log('üîÑ Intentando reconectar...');
            reconnectInterval = setInterval(() => {
                if (peer && !peer.destroyed) {
                    log('üîÑ Reconnect...');
                    peer.reconnect();
                } else {
                    log('üîÑ Recreando peer...');
                    iniciarPeer();
                }
            }, 5000);
        }

        window.contestarLlamada = async function() {
            if (!incomingCallRequest) return;
            log('üìû Contestando llamada...');
            stopRinging();
            if (callTimeout) clearTimeout(callTimeout);
            
            try {
                localStream = await navigator.mediaDevices.getUserMedia({ audio: true, video: false });
                log('‚úÖ Micr√≥fono activado');
                
                document.getElementById('controls-incoming').classList.add('hidden');
                document.getElementById('controls-active').classList.remove('hidden');
                document.getElementById('btn-mute').style.display = 'flex'; 
                setStatus("üü¢ CONECTADO");
                document.getElementById('avatar').innerText = "üîä";
                
                currentCall = incomingCallRequest;
                currentCall.answer(localStream);
                
                currentCall.on('stream', (remoteStream) => {
                    log('üîä Stream remoto recibido');
                    document.getElementById('remoteAudio').srcObject = remoteStream;
                    conectarVisualizador(remoteStream);
                });
                currentCall.on('close', () => {
                    log('üìû Llamada cerrada');
                    finalizarLlamada(false);
                });

            } catch (err) { 
                log('‚ùå Error mic: ' + err.message);
                alert("Error mic: " + err.message); 
                rechazarLlamada(); 
            }
        };

        window.rechazarLlamada = function() {
            log('‚ùå Llamada rechazada');
            if (incomingCallRequest) incomingCallRequest.close();
            resetState();
        };

        window.finalizarLlamada = function(enviarAviso = true) {
            log('üî¥ Finalizando llamada...');
            if (enviarAviso && currentDataConn && currentDataConn.open) {
                currentDataConn.send('CORTAR');
            }
            if (currentCall) currentCall.close();
            if (currentDataConn) currentDataConn.close();
            resetState();
        };

        function resetState() {
            stopRinging();
            if (callTimeout) clearTimeout(callTimeout);
            
            if (localStream) {
                localStream.getTracks().forEach(track => track.stop());
                localStream = null;
            }

            currentCall = null; 
            incomingCallRequest = null; 
            currentDataConn = null;
            
            document.getElementById('controls-incoming').classList.add('hidden');
            document.getElementById('controls-active').classList.add('hidden');
            document.getElementById('btn-mute').style.display = 'none';
            document.getElementById('wave-visualizer').classList.remove('active');
            
            setStatus("‚úÖ Listo para timbre");
            document.getElementById('avatar').innerText = "üîí";
            updateNetworkStatus('online');
            log('‚úÖ Estado reseteado');
        }

        function startRinging() {
            if (!audioContext) return;
            ringtoneOscillator = audioContext.createOscillator();
            const gain = audioContext.createGain();
            ringtoneOscillator.type = 'square';
            ringtoneOscillator.frequency.setValueAtTime(800, audioContext.currentTime);
            ringtoneOscillator.connect(gain);
            gain.connect(audioContext.destination);
            gain.gain.value = 0.1;
            ringtoneOscillator.start();
        }

        function stopRinging() {
            if (ringtoneOscillator) { 
                try { ringtoneOscillator.stop(); } catch(e){} 
                ringtoneOscillator = null; 
            }
            if (navigator.vibrate) navigator.vibrate(0);
        }

        window.toggleMute = function() {
            if (!localStream) return;
            const track = localStream.getAudioTracks()[0];
            isMuted = !isMuted;
            track.enabled = !isMuted;
            document.getElementById('btn-mute').classList.toggle('muted', isMuted);
            log(isMuted ? 'üîá Mute ON' : 'üîä Mute OFF');
        };

        function iniciarVisualizador() {
            const canvas = document.getElementById('wave-visualizer');
            const ctx = canvas.getContext('2d');
            canvas.width = window.innerWidth; 
            canvas.height = 300;
            window.drawWave = function() {
                requestAnimationFrame(window.drawWave);
                if (!analyser) return;
                const bufferLength = analyser.frequencyBinCount; 
                const dataArray = new Uint8Array(bufferLength);
                analyser.getByteTimeDomainData(dataArray);
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.lineWidth = 2; 
                ctx.strokeStyle = '#2ecc71'; 
                ctx.beginPath();
                const sliceWidth = canvas.width * 1.0 / bufferLength; 
                let x = 0;
                for (let i = 0; i < bufferLength; i++) {
                    const v = dataArray[i] / 128.0; 
                    const y = v * (canvas.height / 2);
                    if (i === 0) ctx.moveTo(x, y); 
                    else ctx.lineTo(x, y); 
                    x += sliceWidth;
                }
                ctx.lineTo(canvas.width, canvas.height / 2); 
                ctx.stroke();
            }; 
            window.drawWave();
        }

        function conectarVisualizador(stream) {
            if (!audioContext) return;
            const source = audioContext.createMediaStreamSource(stream);
            analyser = audioContext.createAnalyser();
            analyser.fftSize = 2048;
            source.connect(analyser);
            document.getElementById('wave-visualizer').classList.add('active');
        }

        function setStatus(msg) { 
            document.getElementById('status-text').innerText = msg; 
        }
        
        function updateNetworkStatus(status) {
            const dot = document.getElementById('net-dot');
            const txt = document.getElementById('net-text');
            dot.className = 'dot ' + status;
            txt.innerText = status === 'online' ? 'En L√≠nea' : 'Desconectado';
        }
    </script>
</body>
</html>
